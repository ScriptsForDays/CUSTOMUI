<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom Enhancements - WindUI Custom</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            line-height: 1.6;
            padding: 2rem;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 3rem;
            padding-bottom: 2rem;
            border-bottom: 1px solid #27272a;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, #30ff6a, #60a5fa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .nav {
            margin-bottom: 2rem;
        }

        .nav a {
            color: #30ff6a;
            text-decoration: none;
            font-weight: 500;
            margin-right: 1rem;
        }

        .nav a:hover {
            text-decoration: underline;
        }

        .section {
            margin-bottom: 3rem;
        }

        .section h2 {
            font-size: 2rem;
            margin-bottom: 1rem;
            color: #ffffff;
        }

        .section h3 {
            font-size: 1.5rem;
            margin-top: 2rem;
            margin-bottom: 1rem;
            color: #ffffff;
        }

        .section p {
            color: #a1a1aa;
            margin-bottom: 1rem;
        }

        .code-block {
            background: #1a1a1a;
            border: 1px solid #27272a;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            overflow-x: auto;
        }

        .code-block code {
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            color: #ffffff;
            line-height: 1.6;
        }

        .code-block .comment {
            color: #71717a;
        }

        .method-list {
            list-style: none;
            margin: 1.5rem 0;
        }

        .method-list li {
            background: #1a1a1a;
            border: 1px solid #27272a;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .method-list code {
            color: #30ff6a;
            font-weight: 600;
        }

        .feature-list {
            list-style: none;
            margin: 1rem 0;
        }

        .feature-list li {
            padding: 0.5rem 0;
            color: #a1a1aa;
            padding-left: 1.5rem;
            position: relative;
        }

        .feature-list li:before {
            content: "✅";
            position: absolute;
            left: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="nav">
            <a href="index.html">← Home</a>
            <a href="installation.html">Installation</a>
            <a href="components.html">Components</a>
            <a href="api.html">API Reference</a>
        </div>
        
        <div class="header">
            <h1>Custom Enhancements</h1>
            <p style="color: #a1a1aa;">Enhanced features for better UI control and dynamic updates</p>
        </div>

        <section class="section">
            <h2>Dynamic Dropdown Updates</h2>
            <p>WindUI Custom supports dynamic dropdowns that can automatically fetch data from functions, ModuleScripts, or be updated manually. This is perfect for scenarios where dropdown options change based on runtime data, similar to Rayfield's dynamic dropdowns.</p>

            <h3>Automatic Data Fetching</h3>
            <p><strong>Key Feature:</strong> When you provide a function or ModuleScript path, the dropdown will automatically fetch fresh data <strong>every time it opens</strong>, ensuring you always see the latest data. The function is called both during creation and when the dropdown menu is opened.</p>

            <h4>Using a Function</h4>
            <div class="code-block">
                <code>
<span class="comment">-- Dropdown that fetches players dynamically</span><br>
<span class="comment">-- The function is called when dropdown is created AND every time it opens</span><br>
local playerDropdown = Tab:Dropdown({<br>
&nbsp;&nbsp;&nbsp;&nbsp;Title = "Select Player",<br>
&nbsp;&nbsp;&nbsp;&nbsp;Desc = "Fetches players from game (updates on open)",<br>
&nbsp;&nbsp;&nbsp;&nbsp;Values = function()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;local players = {}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for _, player in ipairs(game:GetService("Players"):GetPlayers()) do<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;table.insert(players, {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Title = player.Name,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Icon = "user"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">-- Return placeholder if no players found</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if #players == 0 then<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return {{ Title = "--" }}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return players<br>
&nbsp;&nbsp;&nbsp;&nbsp;end,<br>
&nbsp;&nbsp;&nbsp;&nbsp;Callback = function(option)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("Selected player:", option.Title)<br>
&nbsp;&nbsp;&nbsp;&nbsp;end<br>
})<br>
<br>
<span class="comment">-- Optional: Manually refresh data from function</span><br>
<span class="comment">-- playerDropdown:RefreshData()</span><br>
<span class="comment">-- Note: Function is automatically called when dropdown opens, so RefreshData() is usually not needed</span></code>
            </div>
            <p><strong>Important:</strong> The function is automatically called every time the dropdown menu opens, ensuring you always see the latest data. You don't need to manually call <code>:RefreshData()</code> unless you want to refresh while the dropdown is closed.</p>

            <h4>Using a ModuleScript</h4>
            <div class="code-block">
                <code>
<span class="comment">-- ModuleScript: MyDataModule (in ReplicatedStorage, ServerStorage, etc.)</span><br>
<span class="comment">-- Can return a table or a function that returns a table</span><br>
<span class="comment">-- Option 1: Return a table directly</span><br>
<span class="comment">-- return {</span><br>
<span class="comment">--     { Title = "Item 1" },</span><br>
<span class="comment">--     { Title = "Item 2" }</span><br>
<span class="comment">-- }</span><br>
<span class="comment">--</span><br>
<span class="comment">-- Option 2: Return a function</span><br>
<span class="comment">-- return function()</span><br>
<span class="comment">--     local items = getItemsFromGame()</span><br>
<span class="comment">--     return items</span><br>
<span class="comment">-- end</span><br>
<br>
local itemDropdown = Tab:Dropdown({<br>
&nbsp;&nbsp;&nbsp;&nbsp;Title = "Select Item",<br>
&nbsp;&nbsp;&nbsp;&nbsp;Desc = "Fetches items from ModuleScript (updates on open)",<br>
&nbsp;&nbsp;&nbsp;&nbsp;Values = "MyDataModule", <span class="comment">-- Searches for ModuleScript in game</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;Callback = function(option)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("Selected:", option.Title)<br>
&nbsp;&nbsp;&nbsp;&nbsp;end<br>
})<br>
<br>
<span class="comment">-- Optional: Manually refresh data from ModuleScript</span><br>
<span class="comment">-- itemDropdown:RefreshData()</span><br>
<span class="comment">-- Note: ModuleScript is automatically accessed when dropdown opens</span></code>
            </div>
            <p><strong>ModuleScript Behavior:</strong> If the ModuleScript returns a function, that function will be called every time the dropdown opens. If it returns a table, that table will be used. The dropdown automatically searches common game locations for the ModuleScript.</p>

            <h3>Manual Updates</h3>
            <p>You can also manually update dropdown values using <code>:SetValues()</code>. This is useful when you want to update the dropdown programmatically, regardless of the original data source:</p>
            <div class="code-block">
                <code>
local dropdown = Tab:Dropdown({<br>
&nbsp;&nbsp;&nbsp;&nbsp;Title = "Dynamic Dropdown",<br>
&nbsp;&nbsp;&nbsp;&nbsp;Values = {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ Title = "Option 1", Icon = "file" },<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ Title = "Option 2", Icon = "folder" },<br>
&nbsp;&nbsp;&nbsp;&nbsp;},<br>
&nbsp;&nbsp;&nbsp;&nbsp;Callback = function(option)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("Selected:", option.Title)<br>
&nbsp;&nbsp;&nbsp;&nbsp;end<br>
})<br>
<br>
<span class="comment">-- Later, update the dropdown values</span><br>
<span class="comment">-- Selection is preserved if the same option still exists</span><br>
dropdown:SetValues({<br>
&nbsp;&nbsp;&nbsp;&nbsp;{ Title = "New Option A", Icon = "star" },<br>
&nbsp;&nbsp;&nbsp;&nbsp;{ Title = "New Option B", Icon = "heart" },<br>
&nbsp;&nbsp;&nbsp;&nbsp;{ Title = "New Option C", Icon = "zap" },<br>
})<br>
<br>
<span class="comment">-- Or refresh from the original data source (if function/ModuleScript)</span><br>
<span class="comment">-- dropdown:RefreshData()</span></code>
            </div>
            <p><strong>Note:</strong> <code>:SetValues()</code> preserves the current selection if the selected option still exists in the new values. If the selection no longer exists, it will be cleared.</p>

            <h3>Features</h3>
            <ul class="feature-list">
                <li><strong>Automatic refresh on open:</strong> Function-based Values are called every time the dropdown opens, ensuring fresh data</li>
                <li>Automatic data fetching from functions or ModuleScripts</li>
                <li>Preserves current selection when possible after updates</li>
                <li>Works with both single-select and multi-select dropdowns</li>
                <li>Handles open menus gracefully during updates</li>
                <li>Clears search filters when values are refreshed</li>
                <li>Automatically recalculates list and canvas sizes</li>
                <li>RefreshData() method to manually refetch from original source</li>
                <li>SetValues() method for manual updates with new data</li>
            </ul>

            <h3>Data Source Locations</h3>
            <p>When using a ModuleScript path (string), WindUI searches in these locations:</p>
            <ul class="feature-list">
                <li>ReplicatedStorage</li>
                <li>ServerStorage</li>
                <li>StarterPlayerScripts</li>
                <li>StarterCharacterScripts</li>
                <li>Workspace</li>
            </ul>
        </section>

        <section class="section">
            <h2>Custom Accent Customization</h2>
            <p>Customize UI accents without creating a full theme. These overrides persist when switching themes, giving you fine-grained control over the UI appearance. <strong>Changes are applied immediately</strong> - the UI updates automatically when you call any SetCustom method.</p>

            <h3>Available Methods</h3>
            <ul class="method-list">
                <li><code>WindUI:SetCustomAccent(color)</code> - Set the accent color</li>
                <li><code>WindUI:SetCustomBackground(color)</code> - Set the background color (supports gradients)</li>
                <li><code>WindUI:SetCustomText(color)</code> - Set the text color</li>
                <li><code>WindUI:SetCustomButton(color)</code> - Set the button color (supports gradients)</li>
                <li><code>WindUI:SetCustomIcon(color)</code> - Set the icon color</li>
                <li><code>WindUI:SetCustomDialog(color)</code> - Set the dialog background color</li>
                <li><code>WindUI:SetCustomOutline(color)</code> - Set the outline color</li>
                <li><code>WindUI:SetCustomProperty(name, value)</code> - Set any custom theme property</li>
            </ul>

            <h3>Examples</h3>
            <div class="code-block">
                <code>
<span class="comment">-- Solid colors (UI updates immediately)</span><br>
WindUI:SetCustomAccent(Color3.fromHex("#30ff6a"))<br>
WindUI:SetCustomBackground(Color3.fromHex("#1a1a1a"))<br>
WindUI:SetCustomText(Color3.fromHex("#ffffff"))<br>
<span class="comment">-- All UI elements using these colors update instantly!</span><br>
<br>
<span class="comment">-- Gradients (UI updates immediately)</span><br>
WindUI:SetCustomBackground(WindUI:Gradient({<br>
&nbsp;&nbsp;&nbsp;&nbsp;["0"] = { Color = Color3.fromHex("#0f0c29"), Transparency = 0 },<br>
&nbsp;&nbsp;&nbsp;&nbsp;["100"] = { Color = Color3.fromHex("#302b63"), Transparency = 0.1 },<br>
}, {<br>
&nbsp;&nbsp;&nbsp;&nbsp;Rotation = 45,<br>
}))<br>
<span class="comment">-- Backgrounds update immediately with the gradient!</span><br>
<br>
<span class="comment">-- Clear overrides (UI updates immediately)</span><br>
WindUI:ClearCustomProperty("Accent")<br>
<span class="comment">-- Accent color reverts to theme default immediately</span><br>
WindUI:ClearCustomOverrides()<br>
<span class="comment">-- All custom overrides cleared, UI reverts to theme defaults immediately</span>
                </code>
            </div>
            
            <h3>Immediate Updates</h3>
            <p><strong>All SetCustom methods update the UI immediately</strong> when called. You don't need to manually refresh or rebuild any UI elements. The library automatically applies changes to all existing UI elements that use the affected theme properties.</p>
            
            <div class="code-block">
                <code>
<span class="comment">-- Example: Dynamic color changes</span><br>
task.spawn(function()<br>
&nbsp;&nbsp;&nbsp;&nbsp;for i = 0, 100 do<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;local hue = i / 100<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;local color = Color3.fromHSV(hue, 1, 1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WindUI:SetCustomAccent(color)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">-- UI updates immediately with each color change!</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;task.wait(0.1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;end<br>
end)
                </code>
            </div>
        </section>

        <section class="section">
            <h2>Installation</h2>
            <div class="code-block">
                <code>
<span class="comment">-- Load WindUI Custom</span><br>
local WindUI = loadstring(game:HttpGet('https://raw.githubusercontent.com/ScriptsForDays/CUSTOMUI/refs/heads/main/dist/main.lua'))()
                </code>
            </div>
        </section>
    </div>
</body>
</html>

